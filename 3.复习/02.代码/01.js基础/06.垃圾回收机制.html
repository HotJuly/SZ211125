<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        
        /*
        垃圾回收机制
                它可以判断某个对象是否正在被其他人使用(或者说,它可以判断某个对象是否有用)
                    如果发现没有人使用某个对象,该对象会被回收

                基础数据类型的数据,只会被覆盖,或者随着对象一起被销毁

                早期版本:引用计数法
                    在每个对象创建的时候,会对其添加一个count属性(不可见),
                        该对象每多一个人使用他,就会对count进行+1操作
                        该对象每少一个人使用他,就会对count进行-1操作
                        如果count为0,就代表该对象需要被回收
                    出现的问题:很有可能出现循环引用的情况,导致count无法归零,最终对象无法被回收

                最新版本:Scanvenger算法
                    该垃圾回收机制,分为两个块区域
                        新生代区
                            该区域中会存储新创建的对象(比较年轻的对象)
                            新生代区由from和to两个数组组成
                                from用于存储上一次出现的所有对象
                                to用于存储当前剩余的所有对象

                            首次扫描流程:
                                1.从全局执行上下文开始扫描对象(window)
                                2.将window所有的直系对象记录到from数组中
                                3.在将from数组中出现的对象内部的所有对象在记录到from数组中(递归扫描)
                                    直到没有对象为止
                                最终from数组中,记录了本轮出现过的所有的对象

                            回收流程: 
                                1.从全局执行上下文开始扫描对象(window)
                                2.将window所有的直系对象记录到to数组中(如果本身就存在于from数组中,那么该对象会被从from数组移到to数组)
                                3.在将to数组中出现的对象内部的所有对象在记录到to数组中(递归扫描)
                                    直到没有对象为止
                                4.当流程3递归扫描结束之后,from数组中只会剩下没有使用的对象
                                    这些对象占用的内存就得到释放

                            扩展:如果一个对象在to数组中出现超过3次,那个该对象就会被放入老生代区(说明该对象是一个长期使用的对象)

                            算法:以空间换时间

                        老生代区
                            该区域中会存储旧的对象(比较老的对象)
                            老生代区只有一个数组,该数组会存储所有的长期保存的对象
                            流程:
                                1.在从window对象开始向下递归扫描的过程中,如果遇到了老生代区的对象
                                    垃圾回收机制会给该对象打上标识(证明他是正在使用的)
                                2.扫描结束之后,开始遍历老生代区数组,有标识的留下(同时把标记清空),没有标识的回收
                                3.需要整合内存碎片,将所有的老生代区对象,紧凑化处理(内存整合,释放无用空间,留作后续使用)

                            算法:以时间换空间
        */

        // var obj = {

        // }

        // var obj2 = obj;

        // obj = null;

        // obj2 = null;

        // var obj = {

        // }

        // var obj2 = {

        // };

        // obj.obj2=obj2;
        // obj2.obj=obj;

        // obj = null;
        // obj2 = null;

        var obj = {
            a:{
                d:{
                    f:{

                    },
                    g:{

                    }
                }
            },
            b:{
                e:{

                }
            },
            c:{

            }
        }

        obj.a.d=null;
    </script>
</body>
</html>